\documentclass[10pt,a4paper]{article}

\usepackage{a4wide}
\setlength{\parskip}{0.5ex plus0.1ex minus0.1ex}
\setlength{\parindent}{0em}

\usepackage[round,longnamesfirst]{natbib}
\usepackage{hyperref}

\newcommand{\strong}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\func}[1]{\mbox{\texttt{#1()}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{\strong{#1}}
\newcommand{\samp}[1]{`\mbox{\texttt{#1}}'}
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\set}[1]{\mathcal{#1}}

\usepackage{Sweave}
%% \VignetteIndexEntry{Introduction to TSP}

\begin{document}

<<echo=FALSE>>=
options(width = 75)
### for sampling
set.seed(1234)
@

\title{Introduction to \pkg{TSP} -- Infrastructure for the Traveling
    Salesperson Problem} 
\author{Michael Hahsler and Kurt Hornik}
\maketitle
\sloppy

\abstract{The traveling salesperson or salesman problem (TSP) is a well known
and important combinatorial optimization problem. The goal is to find the
shortest tour that visits each city in a given list exactly once and then
returns to the starting city.  Despite this simple problem statement, the
TSP belongs to the class of NP-hard problems.

The importance of the TSP arises from the variety of it's applications.
Besides the obvious application for vehicle routing, many other applications,
e.g., computer wiring, cutting wallpaper, job sequencing or several data
visualization techniques, require the solution of a TSP.

In this paper we introduce the R~package \pkg{TSP} which provides a basic
infrastructure for handling and solving the traveling salesman problem.  In
addition to informal S3 classes for specifying a TSP and its (possibly optimal)
solution, the package contains several simple heuristics to find good
solutions. Also an interface to \emph{Concorde}, one of the currently best TSP
solver, is provided.
}

\section{Introduction}
The traveling salesperson problem~\citep[TSP;][]{Lawler1985} is a well known
and important combinatorial optimization problem. The goal is to find the
shortest tour that visits each city in a given list exactly once and then
returns to the starting city.  The TSP has many applications including computer
wiring, vehicle routing, clustering of data arrays and machine
scheduling~\citep{Lenstra1975}.

Formally, the TSP can be stated as: The distances between $n$ cities are
stored in a distance matrix $D$ with elements $d(i,j)$ where $i,j = 1\dots n$
and the diagonal elements $d(i,i) = 0$. A tour can be represented by a
permutation $\pi$ of $\{1, 2,\dots, n\}$ where $\pi(i)$ represents the city
that follows city $i$ on the tour.  The traveling salesperson problem is then
to find a permutation $\pi$ that minimizes

\begin{equation}
    \sum_{i=1}^n d(i, \pi(i)),
\end{equation}
% see Lenstra & Kan 1975: Some simple Applications to the TSP
which is the length of the tour.

In terms of graph theory, cities can be regarded as vertices in a complete,
weighted graph. The edge weights represent the distances between the cities.
The goal is to find a \emph{Hamiltonian cycle} with the least
weight~\citep{Hoffman1985}.

It can be distinguished between the symmetric TSP and the more general
asymmetric TSP.  For the symmetric case, $d(i,j) = d(j,i)$ holds, i.e., it does
not matter if we travel from $i$ to $j$ or the other way round, the distance is
the same. In the asymmetric case, the distances are not equal for all cities
pairs.  Problems of this kind arise when we do not deal with spacial
distances between cities but, e.g, with the cost associated with traveling
between locations. Here the price for the plane ticket between two cities may
be different depending on which way we go. 

It has to be noted that in this paper, following the origin of the TSP,
the term distance is used. Distance is used here exchangeable with
dissimilarity and no restrictions to measures which 
obey the triangle inequality are made. 

The paper is organized as follows:
In Section~\ref{sec:infrastructure} we give an overview of the infrastructure
implemented in \pkg{TSP} and the basic usage.  In Section~\ref{sec:algo} we
present the available algorithms.  In Section~\ref{sec:examples} we give
several examples.  Section~\ref{sec:conclusion} concludes the paper.

\section{Basic infrastructure}\label{sec:infrastructure}

In the package~\pkg{TSP}, a traveling salesperson problem is
defined by an object of class \class{TSP} (symmetric) or \class{ATSP}
(asymmetric). \func{solve\_TSP} 
is used to find a solution, which is represented by
an object of class \class{TOUR}. Figure~\ref{fig:overview} gives a overview
of this infrastructure.

\begin{figure}
    \centering
    \includegraphics[width=14cm]{overview}
    \caption{An overview of the classes in \pkg{TSP}.\label{fig:overview}}
\end{figure}

\class{TSP} objects can be created from a distance matrix (a \class{dist}
object) or a symmetric matrix using \func{TSP}.  \class{ATSP} objects are
created by \func{ATSP} from square matrices representing the distances.
In the creation process, labels are taken and stored as city names in the
object. Several methods are defined for the classes:
\begin{itemize}
    \item \func{print} displays basic information about the problem (number of
        cities and the used distance measure).
    \item \func{n\_of\_cities} returns the number of cities.
    \item \func{labels} returns the city names.
    \item \func{image} produces a shaded matrix plot of the distances
        between cities. The order of the cities can be specified as the
        argument \code{order}.
\end{itemize}

Internally, an object of class \class{TSP} is a \class{dist} object and, 
therefore, if needed, can be coerced to \class{dist} or to a matrix.
An \class{ATSP} object is represented as a square matrix.
Obviously, asymmetric TSPs are more general than symmetric TSPs, hence,
symmetric TSPs can also be represented as asymmetric TSPs.

A popular format to save TSP descriptions to disk which is supported by most
TSP solvers is the format used by \emph{TSPLIB}, a library of sample instances
of the TSP maintained by \cite{Reinelt2004}. The \pkg{TSP} package provides
\func{TSPLIB\_read} and \func{TSPLIB\_write} to read and save
symmetric and asymmetric TSPs. 

The class \class{TOUR} represents a solution to a TSP in form of an integer
permutation vector containing the ordered indices and labels of the cities to
visit. In addition, it stores an attribute indicating the length of the tour.
Again, suitable \func{print} and \func{labels} methods are provided.
The raw permutation vector can be obtained from a tour using \func{as.integer}.

The length of a tour can always be calculated using \func{tour\_length} and
specifying a TSP and a tour. Instead of the tour, an integer permutation vector
calculated outside the \pkg{TSP} package can be used as long as it has the
correct length.

All TSP solvers in \pkg{TSP} use the simple common interface:

\begin{center}
\code{solve\_TSP(x, method, control)} 
\end{center}
\code{x} is the TSP to be solved, \code{method} is a character string
indicating the method used to solve the TSP and \code{control} can contain a
list with additional information used by the solver.  The different algorithms
currently available as methods are described in Section~\ref{sec:algo}.

\section{Algorithms}\label{sec:algo}

The NP-hardness of the TSP make it already for medium sized TSP instances
necessary to rely on heuristics. In \pkg{TSP}, we implemented some simple
heuristics described by \cite{Rosenkrantz1977}: the nearest neighbor algorithm
and some variants of the insertion algorithm.
The package also provides an interface to the Concorde TSP solver. 


\subsection{Nearest neighbor algorithm}
The nearest neighbor algorithm~\citep{Rosenkrantz1977} follows a very simple
greedy procedure: The algorithm starts with a tour containing a randomly chosen
city.  Then the algorithm always adds to the last city in the tour the nearest
not yet visited city. The algorithm stops when all cities are on the tour.  
This algorithm is implemented as method \code{"nn"} for \func{solve\_TSP}.

An extension to this algorithm is to repeat it with each city as
the starting point and then return the best of the found tour. 
This algorithm is implemented as method \code{"repetitive\_nn"}.

\subsection{Insertion algorithms}
All insertion algorithms~\citep{Rosenkrantz1977} start with a tour consisting
of an arbitrary city and then choose in each step a city $k$ not yet on the
tour.  This city is inserted into the existing tour between two consecutive
cities $i$ and $j$, such that $$d(i,k) + d(k,j) - d(i,j)$$ is minimized.  The
algorithms stops when all cities are on the tour.

The insertion algorithms differ in the way the city to be inserted next is
chosen. The following insertion algorithms are implemented:

\begin{description}
\item[Nearest insertion] The city $k$ is chosen in each step as
the city which is \emph{nearest} to a city on the tour.

\item[Farthest insertion] The city $k$ is chosen in each step as
the city which is \emph{farthest} to any of the cities on the tour.

\item[Cheapest insertion] The city $k$ is chosen in each step 
such that the cost of inserting the new city (i.e., the increase
in the tour's length) is minimal.

\item[Arbitrary insertion] The city $k$ is chosen randomly from all cities
not yet on the tour.

\end{description}


The nearest and cheapest insertion algorithms are variants of to the minimum
spanning tree algorithm which is known to be a good algorithm to find a
Hamiltonian cycle in a connected, undirected graph with a close to minimal
weight sum.  For  nearest and cheapest insertion, adding a city to a partial
tour corresponds to adding an edge to a partial spanning tree.  
%
%Here the TSP is solved by finding
%a Hamiltonian cycle in a connected, undirected graph with a minimal weight
%sum. A known method for finding a good solution is to first generate a
%minimum spanning tree.  A spanning tree of a connected, undirected graph is a
%tree composed of all vertices in the graph and a subset of the edges. The
%minimum spanning tree is a graphs spanning tree with minimal weight. Such a
%minimum spanning tree can be found using a distance matrix as input in less
%than $O(n^2)$ (e.g. using the algorithms by \cite{Kruskal1956} or
%\cite{Prim1957}). From the minimum spanning tree a Hamiltonian cycle is built
%using depth first traversal of the tree~\citep{Rosenkrantz1977}.  
%
For TSPs with distances obeying the triangular inequality, the upper bound for
the length of the tour found by the minimum spanning tree algorithm is twice
the optimal tour length.

The idea behind the farthest insertion algorithm is to link cities far outside
into the tour fist to establish an outline of the whole tour early. With this
change, the algorithm cannot be directly related to generating a minimum
spanning tree and thus the upper bound stated above cannot be guaranteed.
However, it can was shown that the algorithm generates tours which approach
$2/3$ times the optimal tour length~\citep{Johnson1885}. 

The insertion algorithms are implemented as methods 
\code{"neatest\_insertion"},
\code{"farthest\_insertion"},
\code{"cheapest\_insertion"} and
\code{"arbitrary\_insertion"}.


\subsection{Concorde}

Concorde~\citep{Applegate1998,Applegate2006} is currently one of the best
implementations for solving symmetric TSPs based on the branch-and-cut method.
In May 2004, Concorde was used to find the optimal solution for the TSP of
visiting all 24,978 cities in Sweden. The computation was carried out on a
cluster with 96 nodes and took in total almost 100 CPU years (assuming a single
CPU Xeon 2.8 GHz processor).

\pkg{TSP} provides a simple interface to Concorde which is used for method
\code{"concorde"}.  It saves the TSP using \func{TSPLIB\_save} and then calls
the Concorde executable and reads back the resulting tour.

\section{Examples}\label{sec:examples}

\subsection{Comparing some heuristics}
In the following example, we use several heuristics to 
find a short path in the \code{USCA50} dataset which contains the
distances between the first 50 cities in the \code{USCA312}
dataset. The \code{USCA312} dataset contains the distances between 
312 cities in the USA and Canada coded as a symmetric TSP.
The smaller dataset is used here, since some heuristics are rather slow.

<<>>=
library("TSP")
data("USCA50")
tsp <- USCA50
tsp
@

The tours using different heuristics are stored in the list \code{tours} and
the tour lengths are compared using the bar plot in Figure~\ref{fig:barplot}.
The horizontal line in the plot represents the optimal solution with a tour
length of 14497. The optimal solution can be found using Concorde
(\code{method = "concorde"}). It is omitted here, since Concorde has to be
installed separately.

<<fig=TRUE, include=FALSE, label=barplot_USCA50, width=7, height=4>>=
tours <- list()
tours$nearest   <- solve_TSP(tsp)
tours$farthest  <- solve_TSP(tsp, method = "farthest_insertion")
tours$cheapest  <- solve_TSP(tsp, method = "cheapest_insertion")
tours$arbitrary <- solve_TSP(tsp, method = "arbitrary_insertion")
tours$nn        <- solve_TSP(tsp, method = "nn")
tours$repetitive_nn    <- solve_TSP(tsp, method = "repetitive_nn")
# tours$concorde  <- solve_TSP(tsp, method = "concorde")

tours

barplot(sapply(tours, FUN = attr, "tour_length"), ylab = "tour length")

## add optimum
opt <- 14497
abline(h = opt, col = "red")
mtext("optimum", at = opt, side = 4, col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-barplot_USCA50}
\caption{Comparison of the tour lengths for the USCA50 dataset.}
\label{fig:barplot}
\end{figure}

%Use the iris data to create a TSP.
%<<>>=
%data("iris")
%tsp <- TSP(dist(iris[-5]))
%tsp
%@
%
%Calculate some tours
%
%<<fig=TRUE, include=FALSE, label=barplot_iris, width=6, height=4>>=
%tours <- list()
%tours$farthest  <- solve_TSP(tsp)
%tours$nearest   <- solve_TSP(tsp, method = "nearest_insertion")
%tours$greedy    <- solve_TSP(tsp, method = "greedy")
%#tours$concorde  <- solve_TSP(tsp, method = "concorde")
%tours
%
%barplot(sapply(tours, FUN = attr, "tour_length"))
%abline(h = 51.77891, col = "red") # optimal length
%@
%
%\begin{figure}
%\centering
%\includegraphics[width=10cm]{TSP-barplot_iris}
%\caption{Comparision of the tour lengths for the iris dataset.}
%\label{fig:barplot}
%\end{figure}
%



\subsection{Finding the shortest Hamiltonian path}

The problem of finding the shortest Hamiltonian path through a graph can be
transformed into the TSP~\citep{Garfinkel1985} with cities and distances
representing the graphs vertices and edge weights, respectively.

Finding the shortest Hamiltonian path through all cities disregarding the
endpoints can be achieved by inserting a `dummy city' which has a distance of
zero to all other cities. The position of this city in the final tour
represents the cutting point for the path. In the following we use a heuristic
to find a short path in the \code{USCA312} dataset.  Inserting dummy cities is
implemented in \pkg{TSP} as \func{insert\_dummy}.

<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
library("TSP")
data("USCA312")
tsp <- insert_dummy(USCA312)
tsp
@

The TSP contains now an additional dummy city and we can try to solve this
TSP and print the labels to see the resulting tour.

<<>>=
tour <- solve_TSP(tsp)
#tour <- solve_TSP(tsp, method ="Concorde")
tour

labels(tour)
which(labels(tour)== "dummy")
@

Since the dummy city has distance zero to all other cities, the path length is
equal to the tour length reported above. The path starts with the first city in
the list after the `dummy' city (the index in the tour is printed above) and
ends with the city right before it. In the example above, this results in
a path from Lihue in Hawaii to Yellowknife in Canada's Northwest Territories.
However, the path found by the heuristic is almost double the optimal path
length found by Concorde with a length of $34928$.

A related problem is to find the shortest Hamiltonian path starting with a
given city. In this case, all distances to the selected city are set to zero,
forcing the evaluation of all possible paths starting with this city and
disregarding the way back from the final city in the tour.  By modifying the
distances the symmetric TSP is changed into an asymmetric TSP since the
distances between the starting city and all other cities are no longer
symmetric.

As an example, we choose the city New York to be the starting city.
We transform the dataset into an asymmetric TSP and set the column 
corresponding to New York to zero before solving the TSP. This means
that the distance to return from the last city in the path
to New York does not contribute to the path length.
We also tell the heuristic to first place the city New York which
helps the heuristic find a better solution than when this city is placed later.

<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
atsp <- ATSP(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
atsp[, ny] <- 0
tour <- solve_TSP(atsp, control = list(start = ny))
tour

head(labels(tour))
tail(labels(tour))
@

The found path begins with New York and cities in New Jersey and
ends in the west of Canada.

Finding the shortest Hamiltonian path which ends in a given city can be achieved
likewise by setting the row corresponding to this city in the distance
matrix to zero.

For finding the shortest Hamiltonian path we can also restrict both end points.
This problem can be transformed to a TSP by replacing the two cities by a
single city which contains the distances from the start point in the columns
and the distances to the end point in the rows. Obviously this is again an
asymmetric TSP.

For the following example, we are only interested in paths starting in New York
and ending in Los Angeles. Therefore, we remove the two cities from the
distance matrix, create an asymmetric TSP and insert a dummy city called
\code{"LA/NY"}. The distances from this dummy city are replaced by the
distances from New York and the distances towards are replaced by the distances
towards Los Angeles.


<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
m <- as.matrix(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
la <- which(labels(USCA312) == "Los Angeles, CA")

atsp <- ATSP(m[-c(ny,la), -c(ny,la)])
atsp <- insert_dummy(atsp, label = "LA/NY")

la_ny <- which(labels(atsp) == "LA/NY")
atsp[la_ny, ] <- c(m[-c(ny,la), ny], 0)
atsp[, la_ny] <- c(m[la, -c(ny,la)], 0)
@

We let the arbitrary insertion heuristic 
start with the dummy city to solve the TSP.

<<>>=
tour <- solve_TSP(atsp, method ="arbitrary", control = list(start=la_ny))
tour

head(labels(tour))
tail(labels(tour))
@

The path moves from New York on to other cities close in the State of New York
and it passes through cities in California before ending in Los Angeles.


\subsection{Rearrangement clustering}
\cite{Climer2006} introduce rearrangement clustering by arranging all objects
in a linear order using a TSP. The authors suggest to find the cluster
boundaries of $k$ clusters by adding $k$ \emph{dummy cities} which have
constant distance $c$ to all other cities and are infinitely far from each
other. \cite{Climer2006} show that in the optimal solution of the TSP, the
dummy cities must separate the most distant cities and thus lie exactly on the
optimal cluster boundaries.

We insert two dummy cities 
into the TSP for the iris dataset and perform rearrangement clustering
using the nearest insertion algorithm. Note that this algorithm 
does not find the optimal solution and it is not guaranteed that the 
dummy cities will present the optimal cluster boundaries.

<<echo=FALSE>>=
set.seed(4444)
@
<<>>=
data("iris")
tsp <- TSP(dist(iris[-5]))
#tsp <- TSP(dist(scale(iris[-5])))
tsp_dummy <- insert_dummy(tsp, n = 2, label = "boundary")
tour <- solve_TSP(tsp_dummy)
@

Next, we plot the TSP's permutated distance matrix using shading to represent
distances. The result is displayed as Figure~\ref{fig:clustering}. Lighter
areas represent larger distances. The additional red lines represent the
positions of the dummy cities in the tour, which mark the found boundaries of
the clusters.


<<fig=TRUE, include=FALSE, label=clustering>>=
## plot the distance matrix
image(tsp_dummy, tour)

## draw lines where the dummy cities are located
abline(h = which(labels(tour)=="boundary"), col = "red")
abline(v = which(labels(tour)=="boundary"), col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-clustering}
\caption{Result of rearrangement clustering using three dummy cities and the 
nearest insertion algorithm on the iris dataset.}
\label{fig:clustering}
\end{figure}

We can also look at how well the found partitioning fits the structure in the
data given by the species field in the dataset.

<<>>=
iris[tour, "Species"]

## do Concorde
# tsp <- TSP(dist(iris[-5]))
# tsp_dummy <- insert_dummy(tsp, n = 3)
# tour <- solve_TSP(tsp_dummy, method = "concorde")
# iris[tour, "Species"]
@


The resulting clustering perfectly splits the iris dataset into a group
containing only examples of the species `Setosa' and a second group containing
examples for `Virginica' and `Versicolor'. Note that since the used heuristic
resolves ties randomly, this result may not be achieved every time.  The
optimal tour is always found by Concorde. However, using three dummy cities,
this method fails to find the three groups in the dataset. The reason is the
considerable overlap between the groups `Virginica' and `Versicolor'.


\section{Conclusion}\label{sec:conclusion}

In this paper we presented the package \pkg{TSP} which implements the
infrastructure to handle and solve TSPs. The package introduces classes for
problem descriptions (\class{TSP} and \class{ATSP}) and for the solution
(\class{TOUR}). Together with a simple interface for solving TSPs, 
it allows for an easy and transparent usage of the package.

With the interface to Concorde, \pkg{TSP} also can use a state of the art
implementation which efficiently computes exact solutions using branch-and-cut.
%
\bibliographystyle{abbrvnat}
\bibliography{tsp}
%
\end{document}

