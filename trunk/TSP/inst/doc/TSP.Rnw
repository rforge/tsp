\documentclass[10pt,a4paper]{article}

\usepackage{a4wide}
\setlength{\parskip}{0.5ex plus0.1ex minus0.1ex}
\setlength{\parindent}{0em}

\usepackage[round,longnamesfirst]{natbib}
\usepackage{hyperref}

\newcommand{\strong}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\func}[1]{\mbox{\texttt{#1()}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{\strong{#1}}
\newcommand{\samp}[1]{`\mbox{\texttt{#1}}'}
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\set}[1]{\mathcal{#1}}

\usepackage{Sweave}
%% \VignetteIndexEntry{Introduction to TSP}

\begin{document}

<<echo=FALSE>>=
options(width = 75)
### for sampling
set.seed(1234)
@

\title{Introduction to \pkg{TSP} -- Infrastructure for the Traveling
    Salesperson Problem} 
\author{Michael Hahsler and Kurt Hornik}
\maketitle
\sloppy

\abstract{The traveling salesperson or salesman problem (TSP) is a well
  known and important combinatorial optimization problem. The goal is to
  find the shortest tour that visits each city in a given list exactly
  once and then returns to the starting city.  Despite this simple
  problem statement, the TSP belongs to the class of NP-hard problems.

  The importance of the TSP arises from the variety of it's
  applications.  Apart from the obvious application for vehicle routing,
  many other applications, e.g., computer wiring, cutting wallpaper, job
  sequencing or several data visualization techniques, require the
  solution of a TSP.

  In this paper we introduce the R~package \pkg{TSP} which provides a
  basic infrastructure for handling and solving the traveling
  salesperson problem.  The package features informal S3 classes for
  specifying a TSP and its (possibly optimal) solution as well as
  several simple heuristics to find good solutions.  In addition, it
  provides an interface to \emph{Concorde}, one of the best TSP solvers
  currently available.}

\section{Introduction}
The traveling salesperson problem~\citep[TSP;][]{Lawler1985} is a well known
and important combinatorial optimization problem. The goal is to find the
shortest tour that visits each city in a given list exactly once and then
returns to the starting city.  The TSP has many applications including computer
wiring, vehicle routing, clustering of data arrays and machine
scheduling~\citep{Lenstra1975}.

Formally, the TSP can be stated as: The distances between $n$ cities are stored
in a distance matrix $D$ with elements $d(i,j)$ where $i,j = 1\dots n$ and the
diagonal elements $d(i,i) = 0$. A tour can be represented by a cyclic
permutation $\pi$ of $\{1, 2,\dots, n\}$ where $\pi(i)$ represents the city
that follows city $i$ on the tour. The traveling salesperson problem is then
to find a permutation $\pi$ that minimizes

\begin{equation}
    \sum_{i=1}^n d(i, \pi(i)),
\end{equation}
% see Lenstra & Kan 1975: Some simple Applications to the TSP
which is called the \emph{length of the tour.}

In terms of graph theory, cities can be regarded as vertices in a complete,
weighted graph. The edge weights represent the distances between the cities.
The goal is to find a \emph{Hamiltonian cycle} with the least
weight~\citep{Hoffman1985}.

It can be distinguished between the symmetric TSP and the more general
asymmetric TSP.  For the symmetric case, $d(i,j) = d(j,i)$ holds, i.e.,
it does not matter if we travel from $i$ to $j$ or the other way round,
the distance is the same. In the asymmetric case, the distances are not
equal for all pairs of cities.  Problems of this kind arise when we do
not deal with spatial distances between cities but, e.g., with the cost
associated with traveling between locations. Here the price for the
plane ticket between two cities may be different depending on which way
we go.

It has to be noted that in this paper, following the origin of the TSP,
the term \emph{distance} is used.  Distance is used here exchangeably
with dissimilarity and no restrictions to measures which obey the
triangle inequality are made.

The paper is organized as follows:
In Section~\ref{sec:infrastructure} we give an overview of the infrastructure
implemented in \pkg{TSP} and the basic usage.  In Section~\ref{sec:algo} we
present the available algorithms.  In Section~\ref{sec:examples} we give
several examples.  Section~\ref{sec:conclusion} concludes the paper.

\section{Basic infrastructure}\label{sec:infrastructure}

In the package~\pkg{TSP}, a traveling salesperson problem is
defined by an object of class \class{TSP} (symmetric) or \class{ATSP}
(asymmetric). \func{solve\_TSP} 
is used to find a solution, which is represented by
an object of class \class{TOUR}. Figure~\ref{fig:overview} gives a overview
of this infrastructure.

\begin{figure}
    \centering
    \includegraphics[width=14cm]{overview}
    \caption{An overview of the classes in \pkg{TSP}.\label{fig:overview}}
\end{figure}

\class{TSP} objects can be created from a distance matrix (a \class{dist}
object) or a symmetric matrix using the creator function \func{TSP} or coercion
with \func{as.TSP}.  Similarly, \class{ATSP} objects are created by \func{ATSP}
or \func{as.ATSP} from square matrices representing the distances.  In the
creation process, labels are taken and stored as city names in the object or
can be explicitely given as arguments to the creator functions.  Several
methods are defined for the classes:
\begin{itemize}
    \item \func{print} displays basic information about the problem (number of
        cities and the used distance measure).
    \item \func{n\_of\_cities} returns the number of cities.
    \item \func{labels} returns the city names.
    \item \func{image} produces a shaded matrix plot of the distances
        between cities. The order of the cities can be specified as the
        argument \code{order}.
\end{itemize}

Internally, an object of class \class{TSP} is a \class{dist} object and, 
therefore, if needed, can be coerced to \class{dist} or to a matrix.
An \class{ATSP} object is represented as a square matrix.
Obviously, asymmetric TSPs are more general than symmetric TSPs, hence,
symmetric TSPs can also be represented as asymmetric TSPs.

A popular format to save TSP descriptions to disk which is supported by
most TSP solvers is the format used by \emph{TSPLIB}, a library of
sample instances of the TSP maintained by \cite{Reinelt2004}. The
\pkg{TSP} package provides \func{read\_TSPLIB} and \func{write\_TSPLIB}
to read and save symmetric and asymmetric TSPs.

The class \class{TOUR} represents a solution to a TSP in form of an integer
permutation vector containing the ordered indices and labels of the cities to
visit. In addition, it stores an attribute indicating the length of the tour.
Again, suitable \func{print} and \func{labels} methods are provided.  The raw
permutation vector (i.e., the order in which cities are visited) can be
obtained from a tour using \func{as.integer}. With \func{cut\_tour}, a
circular tour can be split at a specified city resulting in a path represented
by a vector of city indices.

The length of a tour can always be calculated using \func{tour\_length} and
specifying a TSP and a tour. Instead of the tour, an integer permutation vector
calculated outside the \pkg{TSP} package can be used as long as it has the
correct length.

All TSP solvers in \pkg{TSP} use the simple common interface:

\begin{center}
\code{solve\_TSP(x, method, control)} 
\end{center}
where \code{x} is the TSP to be solved, \code{method} is a character
string indicating the method used to solve the TSP and \code{control}
can contain a list with additional information used by the solver.  The
different algorithms currently available as methods are described in
Section~\ref{sec:algo}.

\section{Algorithms}\label{sec:algo}

The NP-completeness of the TSP makes it already for medium sized TSP instances
necessary to rely on heuristics. In \pkg{TSP}, we implemented some simple
heuristics described by \cite{Rosenkrantz1977}: the nearest neighbor algorithm
and some variants of the insertion algorithm.
The package also provides an interface to the Concorde TSP solver. 


\subsection{Nearest neighbor algorithm}
The nearest neighbor algorithm~\citep{Rosenkrantz1977} follows a very simple
greedy procedure: The algorithm starts with a tour containing a randomly chosen
city.  Then the algorithm always adds to the last city in the tour the nearest
not yet visited city. The algorithm stops when all cities are on the tour.  
This algorithm is implemented as method \code{"nn"} for \func{solve\_TSP}.

An extension to this algorithm is to repeat it with each city as
the starting point and then return the best of the found tours. 
This algorithm is implemented as method \code{"repetitive\_nn"}.

\subsection{Insertion algorithms}
All insertion algorithms~\citep{Rosenkrantz1977} start with a tour consisting
of an arbitrary city and then choose in each step a city $k$ not yet on the
tour.  This city is inserted into the existing tour between two consecutive
cities $i$ and $j$, such that $$d(i,k) + d(k,j) - d(i,j)$$ is minimized.  The
algorithms stops when all cities are on the tour.

The insertion algorithms differ in the way the city to be inserted next is
chosen. The following insertion algorithms are implemented:

\begin{description}
\item[Nearest insertion] The city $k$ is chosen in each step as
the city which is \emph{nearest} to a city on the tour.

\item[Farthest insertion] The city $k$ is chosen in each step as
the city which is \emph{farthest} to any of the cities on the tour.

\item[Cheapest insertion] The city $k$ is chosen in each step 
such that the cost of inserting the new city (i.e., the increase
in the tour's length) is minimal.

\item[Arbitrary insertion] The city $k$ is chosen randomly from all cities
not yet on the tour.

\end{description}


The nearest and cheapest insertion algorithms are variants of to the minimum
spanning tree algorithm which is known to be a good algorithm to find a
Hamiltonian cycle with a close to minimal weight sum in a connected, undirected
graph.  For nearest and cheapest insertion, adding a city to a partial tour
corresponds to adding an edge to a partial spanning tree.  
%
%Here the TSP is solved by finding
%a Hamiltonian cycle in a connected, undirected graph with a minimal weight
%sum. A known method for finding a good solution is to first generate a
%minimum spanning tree.  A spanning tree of a connected, undirected graph is a
%tree composed of all vertices in the graph and a subset of the edges. The
%minimum spanning tree is a graphs spanning tree with minimal weight. Such a
%minimum spanning tree can be found using a distance matrix as input in less
%than $O(n^2)$ (e.g. using the algorithms by \cite{Kruskal1956} or
%\cite{Prim1957}). From the minimum spanning tree a Hamiltonian cycle is built
%using depth first traversal of the tree~\citep{Rosenkrantz1977}.  
%
For TSPs with distances obeying the triangular inequality, the upper bound for
the length of the tour found by the minimum spanning tree algorithm is twice
the optimal tour length.

The idea behind the farthest insertion algorithm is to link cities far outside
into the tour fist to establish an outline of the whole tour early. With this
change, the algorithm cannot be directly related to generating a minimum
spanning tree and thus the upper bound stated above cannot be guaranteed.
However, it can was shown that the algorithm generates tours which approach
$2/3$ times the optimal tour length~\citep{Johnson1985}. 

The insertion algorithms are implemented as methods 
\code{"nearest\_insertion"},
\code{"farthest\_insertion"},
\code{"cheapest\_insertion"} and
\code{"arbitrary\_insertion"}.


\subsection{Concorde}

Concorde~\citep{Applegate1998,Applegate2006} is currently one of the best
implementations for solving symmetric TSPs based on the branch-and-cut method.
In May 2004, Concorde was used to find the optimal solution for the TSP of
visiting all 24,978 cities in Sweden. The computation was carried out on a
cluster with 96 nodes and took in total almost 100 CPU years (assuming a single
CPU Xeon 2.8 GHz processor).

\pkg{TSP} provides a simple interface to Concorde which is used for method
\code{"concorde"}.  It saves the TSP using \func{write\_TSPLIB} and then calls
the Concorde executable and reads back the resulting tour.

\section{Examples}\label{sec:examples}

\subsection{Comparing some heuristics}

In the following example, we use several heuristics to find a short path
in the \code{USCA50} data set which contains the distances between the
first 50 cities in the \code{USCA312} data set. The \code{USCA312} data
set contains the distances between 312 cities in the USA and Canada
coded as a symmetric TSP.  The smaller data set is used here, since some
of the heuristic solvers employed are rather slow.

<<>>=
library("TSP")
data("USCA50")
tsp <- USCA50
tsp
@


We calculate tours using different heuristics and store the results in the the
list \code{tours}. As an example, we show the first tour which displays the
used method, the number of cities involved and the tour length.  All tour
lengths are compared using the dot chart in Figure~\ref{fig:dotchart}.  For the
chart, we add a point for the optimal solution which has a tour length of
14497. The optimal solution can be found using Concorde (\code{method =
"concorde"}).  It is omitted here, since Concorde has to be installed
separately.

<<echo=FALSE>>=
set.seed(1234)
@


<<fig=TRUE, include=FALSE, label=dotchart_USCA50, width=7, height=4>>=
methods <- c("nearest_insertion", "farthest_insertion", "cheapest_insertion",
    "arbitrary_insertion", "nn", "repetitive_nn")

tours <- lapply(methods, FUN = function(m) solve_TSP(tsp, method = m))
names(tours) <- methods
# tours$concorde  <- solve_TSP(tsp, method = "concorde")
# tours$concorde  <- solve_TSP(tsp, method = "linkern")

tours[[1]]


opt <- 14497
dotchart(c(sapply(tours, FUN = attr, "tour_length"), optimal = opt), 
xlab = "tour length", xlim = c(0, 20000))
## add optimum
#abline(v = opt, col = "red")
#mtext("optimum", at = opt, side = 3, col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-dotchart_USCA50}
\caption{Comparison of the tour lengths for the USCA50 data set.}
\label{fig:dotchart}
\end{figure}


\subsection{Finding the shortest Hamiltonian path}

The problem of finding the shortest Hamiltonian path through a graph can be
transformed into the TSP with cities and distances representing the graphs
vertices and edge weights, respectively~\citep{Garfinkel1985}. 

Finding the shortest Hamiltonian path through all cities disregarding
the endpoints can be achieved by inserting a `dummy city' which has a
distance of zero to all other cities. The position of this city in the
final tour represents the cutting point for the path. In the following
we use a heuristic to find a short path in the \code{USCA312} data set.
Inserting dummy cities is implemented in \pkg{TSP} as
\func{insert\_dummy}.

<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
library("TSP")
data("USCA312")
tsp <- insert_dummy(USCA312, label = "cut")
tsp
@

The TSP contains now an additional dummy city and we can try to solve this
TSP and print the labels to see the resulting tour.

<<>>=
tour <- solve_TSP(tsp, method="farthest_insertion")
#tour <- solve_TSP(tsp, method ="concorde")
tour
@

Since the dummy city has distance zero to all other cities, the path length is
equal to the tour length reported above. The path starts with the first city in
the list after the `dummy' city  and ends with the city right before it. 
We use \func{cut\_path} to create a path and show the 
first and last 6 cities on it.

<<>>=
path <- cut_tour(tour, "cut")
head(labels(path))
tail(labels(path))
@

The tour found in the example results in a path from Prince Rupert in
British Columbia to Lihue on Hawaii. Such a tour can also be 
visualized using the packages \pkg{sp}, \pkg{maps} and \pkg{maptools}.

<<fig=TRUE, include=FALSE, label=map1, width=8, height=8>>=
library("maps")
library("sp")
library("maptools")

data("USCA312_map")

plot_path <- function(path){
    plot(as(USCA312_coords, "Spatial"), axes = TRUE)
    plot(USCA312_basemap, add = TRUE, col = "gray")
    points(USCA312_coords, pch = 3, cex = 0.4, col = "red")
    
    path_line <- SpatialLines(list(Lines(list(Line(USCA312_coords[path,])))))
    plot(path_line, add=TRUE, col = "black")
    points(USCA312_coords[c(head(path,1), tail(path,1)),], pch = 19, 
        col = "black")
}

plot_path(path)
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map1}
\caption{A ``short'' Hamiltonian path for the USCA312 dataset.}
\label{fig:map1}
\end{figure}

The map containing the path is presented in Figure~\ref{fig:map1}.
It has to be mentioned, that the
path found by the used heuristic is almost double the optimal path length found
by Concorde with a length of $34928$, ilustrating the power of modern 
TSP algorithms.

For the following two examples, we show in a very low level way how the
distance matrix between cities can be modified to solve related shortest
Hamiltonian path problems. These examples serve as illustrations of how
modifications can be made to transform different problems into a TSP.

The first problem is to find the shortest Hamiltonian path starting with a
given city. In this case, all distances to the selected city are set to zero,
forcing the evaluation of all possible paths starting with this city and
disregarding the way back from the final city in the tour.  By modifying the
distances the symmetric TSP is changed into an asymmetric TSP since the
distances between the starting city and all other cities are no longer
symmetric.

As an example, we choose the city New York to be the starting city.
We transform the data set into an asymmetric TSP and set the column 
corresponding to New York to zero before solving the TSP. This means
that the distance to return from the last city in the path
to New York does not contribute to the path length.
We use the nearest insertion heuristic 
to calculate a tour and then cut at New York City to create a path.


<<echo=FALSE>>=
set.seed(1234)
@

<<fig=TRUE, include=FALSE, label=map2, width=8, height=8>>=
atsp <- as.ATSP(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
atsp[, ny] <- 0
tour <- solve_TSP(atsp, method ="nearest_insertion")
tour
path <- cut_tour(tour, ny, exclude_cut = FALSE)

plot_path(path)

head(labels(path))
tail(labels(path))
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map2}
\caption{A Hamiltonian path for the USCA312 dataset starting in New York City.}
\label{fig:map2}
\end{figure}

The found path 
is presented in Figure~\ref{fig:map2}. It
begins with New York City and cities in New Jersey and
ends in north east of Canada. 
%The path shows the typical behavior 
%of the nearest neighbor heuristic with first connecting the cities close by and
%then making rather big ``jumps'' for the final cities.

Finding the shortest Hamiltonian path which ends in a given city can be achieved
likewise by setting the row corresponding to this city in the distance
matrix to zero.

For finding the shortest Hamiltonian path we can also restrict both end points.
This problem can be transformed to a TSP by replacing the two cities by a
single city which contains the distances from the start point in the columns
and the distances to the end point in the rows. Obviously this is again an
asymmetric TSP.

For the following example, we are only interested in paths starting in New York
and ending in Los Angeles. Therefore, we remove the two cities from the
distance matrix, create an asymmetric TSP and insert a dummy city called
\code{"LA/NY"}. The distances from this dummy city are replaced by the
distances from New York and the distances towards are replaced by the distances
towards Los Angeles.


<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
m <- as.matrix(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
la <- which(labels(USCA312) == "Los Angeles, CA")

atsp <- ATSP(m[-c(ny,la), -c(ny,la)])
atsp <- insert_dummy(atsp, label = "LA/NY")

la_ny <- which(labels(atsp) == "LA/NY")
atsp[la_ny, ] <- c(m[-c(ny,la), ny], 0)
atsp[, la_ny] <- c(m[la, -c(ny,la)], 0)
@

We use again the nearest insertion heuristic.

<<fig=TRUE, include=FALSE, label=map3, width=8, height=8>>=
tour <- solve_TSP(atsp, method ="nearest_insertion")
tour

path_labels <- c("New York, NY", 
    labels(cut_tour(tour, la_ny)), "Los Angeles, CA")
path_ids <- match(path_labels, labels(USCA312))

head(path_labels)
tail(path_labels)

plot_path(path_ids)
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map3}
\caption{A Hamiltonian path for the USCA312 dataset starting in New York City
and ending in Los Angles.}
\label{fig:map3}
\end{figure}

The path moves from New York on to other cities close in the State of New York
and it passes through cities in California before ending in Los Angeles.
The whole path is displayed in Figure~\ref{fig:map3}.


\subsection{Rearrangement clustering}
\cite{Climer2006} introduce rearrangement clustering by arranging all objects
in a linear order using a TSP. The authors suggest to find the cluster
boundaries of $k$ clusters by adding $k$ \emph{dummy cities} which have
constant distance $c$ to all other cities and are infinitely far from each
other. \cite{Climer2006} show that in the optimal solution of the TSP, the
dummy cities must separate the most distant cities and thus lie exactly on the
optimal cluster boundaries.

For the example, we use the well known iris data set. Since we know that the
dataset contains thre classes denoted by the attribute called \code{"Species"},
we insert three dummy cities into the TSP for the iris data set and perform
rearrangement clustering using the nearest insertion algorithm. Note that this
algorithm does not find the optimal solution and it is not guaranteed that the
dummy cities will present the optimal cluster boundaries.

<<echo=FALSE>>=
set.seed(4444)
@
<<>>=
data("iris")
tsp <- TSP(dist(iris[-5]), labels = iris[, "Species"])
#tsp <- TSP(dist(scale(iris[-5])))
tsp_dummy <- insert_dummy(tsp, n = 3, label = "boundary")
tour <- solve_TSP(tsp_dummy)
@

Next, we plot the TSP's permuted distance matrix using shading to
represent distances. The result is displayed as
Figure~\ref{fig:clustering}. Lighter areas represent larger
distances. The additional red lines represent the positions of the dummy
cities in the tour, which mark the found boundaries of the clusters.


<<fig=TRUE, include=FALSE, label=clustering>>=
## plot the distance matrix
image(tsp_dummy, tour)

## draw lines where the dummy cities are located
abline(h = which(labels(tour)=="boundary"), col = "red")
abline(v = which(labels(tour)=="boundary"), col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-clustering}
\caption{Result of rearrangement clustering using three dummy cities and the 
nearest insertion algorithm on the iris data set.}
\label{fig:clustering}
\end{figure}


One pair of red horizontal and vertical lines exactly separates the darker from
lighter areas. The second pair occurs inside the larger dark.  We can look at
how well the found partitioning fits the structure in the data given by the
species field in the data set. Since we used the species as the city labels in
the TSP, the labels in the tour represent the partitioning with the dummy
cities named `boundary' seperating groups.

<<>>=
labels(tour)

## do Concorde
# tour <- solve_TSP(tsp_dummy, method = "concorde")
# labels(tour)
@


On boundary perfectly splits the iris data set into a group containing only
examples of the species `Setosa' and a second group containing examples for
`Virginica' and `Versicolor'. However, the second boundary only separates two
examples of the species `Virginica' from other examples of the same species.
This indicates that in the path generated by the TSP at exactly this point a
large jump must have ocurred.  Even in the optimal tour found by Concorde, this
problem occurs.  A reason why the rearrangement clustering fails to split the
data into three groups is the considerable overlap between the groups
`Virginica' and `Versicolor'.
\section{Conclusion}\label{sec:conclusion}

In this paper we presented the package \pkg{TSP} which implements the
infrastructure to handle and solve TSPs. The package introduces classes for
problem descriptions (\class{TSP} and \class{ATSP}) and for the solution
(\class{TOUR}). Together with a simple interface for solving TSPs, 
it allows for an easy and transparent usage of the package.

With the interface to Concorde, \pkg{TSP} also can use a state of the art
implementation which efficiently computes exact solutions using branch-and-cut.
%
\bibliographystyle{abbrvnat}
\bibliography{tsp}
%
\end{document}

