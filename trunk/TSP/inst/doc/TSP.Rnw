\documentclass[10pt,a4paper]{article}

\usepackage{a4wide}
\setlength{\parskip}{0.5ex plus0.1ex minus0.1ex}
\setlength{\parindent}{0em}

\usepackage[round,longnamesfirst]{natbib}
\usepackage{hyperref}

\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\strong}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\func}[1]{\mbox{\texttt{#1()}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{\strong{#1}}
\newcommand{\samp}[1]{`\mbox{\texttt{#1}}'}
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\set}[1]{\mathcal{#1}}

\usepackage{Sweave}
%% \VignetteIndexEntry{Introduction to TSP}

\begin{document}

<<echo=FALSE>>=
options(width = 75)
### for sampling
set.seed(1234)
@

\title{Introduction to \pkg{TSP} -- Infrastructure for the Traveling
    Salesperson Problem} 
\author{Michael Hahsler and Kurt Hornik}
\maketitle
\sloppy

\abstract{The traveling salesperson or salesman problem (TSP) is a well
  known and important combinatorial optimization problem. The goal is to
  find the shortest tour that visits each city in a given list exactly
  once and then returns to the starting city.  Despite this simple
  problem statement, the TSP belongs to the class of NP-complete problems.

  The importance of the TSP arises from the variety of it's
  applications.  Apart from the obvious application for vehicle routing,
  many other applications, e.g., computer wiring, cutting wallpaper, job
  sequencing or several data visualization techniques, require the
  solution of a TSP.

  In this paper we introduce the R~package \pkg{TSP} which provides a
  basic infrastructure for handling and solving the traveling
  salesperson problem.  The package features informal S3 classes for
  specifying a TSP and its (possibly optimal) solution as well as
  several heuristics to find good solutions. In addition, it
  provides an interface to \emph{Concorde}, one of the best exact TSP solvers
  currently available.}

\section{Introduction}
The traveling salesperson problem~\citep[TSP;][]{Lawler1985, Gutin2002} 
is a well known
and important combinatorial optimization problem. The goal is to find the
shortest tour that visits each city in a given list exactly once and then
returns to the starting city.  The TSP has many applications including vehicle
routing, computer wiring, machine sequencing and scheduling, frequency
assignment in communication networks and structuring of
matrices~\citep{Lenstra1975, Punnen2002}.

Formally, the TSP can be stated as: The distances between $n$ cities are stored
in a distance matrix $D$ with elements $d_{i,j}$ where $i,j = 1\dots n$ and the
diagonal elements $d_{i,i} = 0$. A tour can be represented by a cyclic
permutation $\pi$ of $\{1, 2,\dots, n\}$ where $\pi(i)$ represents the city
that follows city $i$ on the tour. The traveling salesperson problem is then
to find a permutation $\pi$ that minimizes the  \emph{length of the tour}
denoted by

\begin{equation}
    \sum_{i=1}^n d_{i\pi(i)}.
\end{equation}
% see Lenstra & Kan 1975: Some simple Applications to the TSP

Depending on the nature of the 
distance matrix $D$, one can distinguish between the symmetric
TSP and the more general asymmetric TSP. For the symmetric case, $d_{ij} =
d_{ji}$ holds, i.e., it does not matter if we travel from $i$ to $j$ or the
other way round, the distance is the same. In the asymmetric case (called
ATSP), the
distances are not equal for all pairs of cities. Problems of this kind arise
when we do not deal with spatial distances between cities but, e.g., with the
cost associated with traveling between locations. Here the price for the plane
ticket between two cities may be different depending on which way we go.
\marginpar{ATSP to TSP missing}

It has to be noted that in this paper, following the origin of the TSP, the
term \emph{distance} is used.  Distance is used here exchangeably with
dissimilarity or cost and unless explicitely stated no restrictions to measures
which obey the triangle inequality are made.

In this paper we give a very brief overview of the TSP and introduce the
R package \pkg{TSP} which provides a infrastructure for handling and
solving TSPs in R.

The paper is organized as follows:
\marginpar{1. section is missing}
In Section~\ref{sec:infrastructure} we give an overview of the infrastructure
implemented in \pkg{TSP} and the basic usage.  In Section~\ref{sec:algo} we
present the available algorithms.  In Section~\ref{sec:examples} we give
several examples.  Section~\ref{sec:conclusion} concludes the paper.

\section{Theory}\label{sec:TSP}
In this section, we briefly summarize some properties of the TSP
which are important to the rest of the paper.

\subsection{Different formulations of the TSP}\label{sec:formulations}
Other than the permutation problem in the introduction, the TSP can also be
formulated as a graph theoretic problem. Here the TSP is regarded as a
complete graph $G = (V, E)$, where the cities correspond to the node set  $V =
\{1,2,\cdots,n\}$ and each edge $e_i \in E$ has an associated weight 
$w_i$ representing
the distance between the nodes it connects.  If the graph is not complete, the
missing edges can be replaced by edges with very large distances.  The goal is
then to find a \emph{Hamiltonian cycle},i.e. a cycle which visits every node in
the graph exactly once, with the least weight in the graph~\citep{Hoffman1985}.
This formulation naturally leads to procedures involving minimum spanning
trees, edge exchanges to construct and improve tours.

Other representations are as linear and integer programming 
problems~\citep[see, e.g.,][]{Punnen2002}. 
The linear programming problem is to 
find for a graph $G$ a $0$-$1$ vector $X=(x_1,x_2,\cdots,x_m)$ which
minimizes

\[
\begin{array}{rl}
    \text{Minimize }     & \sum_{i=1}^m{w_ix_i} \\[3mm] 
    \text{Subject to }   & \\
                        & X \in P(F) \\
\end{array}
\]

where 
$m$ is the number of edges in $G$ and
$w_i$ is the weight of edge $e_i$. 
An element in $X$ is only $1$ if the corresponding edge is on the tour and
$0$ otherwise. $P(F)$ is the convex hull of the family of all tours
in $G$.

The problem with the linear programming formulation 
is that the comlete linear inequality 
description of $P(F)$ is not known. 


The integer programming formulation is based on the assignment problem
which is described as follows:

\[
\begin{array}{rl}
    \text{Minimize }     & \sum_{i=1}^n\sum_{j=1}^n{d_{ij}x_{ij}} \\[3mm]
    \text{Subject to }   & \\
                        & \sum_{i=1}^n{x_{ij}=1}, j=1,\cdots,n, \\
                        & \sum_{j=1}^n{x_{ij}=1}, i=1,\cdots,n, \\
                        & x_{ij} = 0 \text{ or } 1 \\
\end{array}
\]

The solution $X = (x_{ij})$ of the assignment problem represents a tour 
or a collection of subtour (cycles which do not contain all nodes)
where all edges which correspond to the elements $x_{ij}$ which are $1$ 
are in the tour or a subtour. Additional restrictions,
called subtour elimination constraints, are necessary 
to avoid subtours. Several constraints have been 
developed~\citep[see][]{Punnen2002}.
The linear programming problem represents a relaxation of the 
integer programming formulation.

Integer programming and especially the linear programming relaxation 
is extensively used by modern TSP solvers where a  partial descriptions of
contraints is used which is then improved iteratively in a 
branch-and-bound approach.

\subsection{Useful manipulations of the distance matrix}

Sometimes it is useful to transform the distance matrix $D = (d_{ij})$ of a TSP
into a different matrix $D' = (d'_{ij})$
which has the same optimal solution. Such a transformation
requires that for any Hamiltonian cycle $H$ in a graph represented
by a distance matrix $D$ the equality

\begin{equation*}
\sum_{i,j \in H}{d_{ij}} = \alpha \sum_{i,j \in H}{d'_{ij}} + \beta,
\end{equation*}

with $\alpha > 0$ and $\beta \in \mathbb{R}$ holds.
From the equality we see that addititve and multiplicative constants
leave the optimal solution invariant. 

A different manipulation is to reformulate a asymmetric TSP
as a symmetric TSP.
This is possible by doubling the number of cities~\citep{Jonker1983}. For each
city a dummy city is added. Between each city and its corresponding dummy city
a very small distance (e.g., $-\infty$) is used.  This makes sure that each
cities always occurs in the solution together with its dummy city. The original
distances are used between the cities and the dummy cities, where each city is
responsible for the distance going to the city and the dummy city is
responsible for the distance coming from the city. The distances between all
cities and the distances between all dummy cities are set to, a very large
value (e.g., $\infty$) which makes these edges infeasible.
An example for three cities is given in the following, where the
asymmetric TSP to the left is formulated 
as a symmetric TSP to the right.

\begin{equation*}
\begin{pmatrix}
    0       &d_{1,2}    &d_{1,3}    \\
    d_{2,1} &0          &d_{2,3}    \\
    d_{3,1} &d_{3,2}    &0          \\
\end{pmatrix}
\Longleftrightarrow
\begin{pmatrix}
  0         &\infty     &\infty     & -\infty       &d_{2,1}    &d_{3,1}    \\
  \infty    &0          &\infty     & d_{1,2} &-\infty          &d_{3,1}    \\
  \infty    &\infty     &0          & d_{1,3} &d_{2,3}    &-\infty          \\
  -\infty         &d_{1,2}    &d_{1,3}    & 0       &\infty    &\infty      \\
  d_{2,1}   &-\infty          &d_{2,3}    & \infty &0         &\infty       \\  
  d_{3,1}   &d_{3,2}    &-\infty          & \infty &\infty   &0             \\
\end{pmatrix}
\end{equation*}

Instead of the infinity values suitably large negative and positive values
can be used.
The new symmetric TSP can be solved using techniques for symmetric TSPs 
(which are currently far more advanced than techniques for ATSPs). 
Removing the dummy cities from the resulting tour gives the  solution
for the original ATSP.

\marginpar{Explain paths here?}


\subsection{Exact solutions to the TSP}\label{sec:algo}

\marginpar{should it be $(n-1)!$?}
Finding the exact solution to a TSP with $n$ cities requires to check $n!$
possible tours. To evaluate all possible tours is infeasible for even small
TSP instances. However, algorithmic procedures like dynamic
programming and branch-and-bound can be used improve efficiency. 

\cite{Held1962} presented the following dynamic programming formulation for
the TSP. The aim is to find the optimal 
permutation $\pi = \{1, i_2, i_3,\dots,i_n\}$
of the integers $1$ through $n$ representing the order in which the
cities are visited. Given $S \subset \{2, 3, \dots, n\}$ and $l \in S$, let
$d^*(S, l)$ denote the length of the shortest path from city $1$ to city $l$,
visiting all cities in between. For $S = \{l\}$, $d^*(S,l)$ is defined
as $d_{1l}$. The shortest path for larger sets with $|S| > 1$ is

\begin{equation}
    d^*(S,l) = \mathrm{min}_{m \in S-l}\{d^*(S-l,m) + d_{ml}\}.
    %\text{ for } |S| > 1.
\end{equation}

Finally, the minimal tour length for a complete tour which includes returning
to city $1$ is

\begin{equation}
    d^{**} = \mathrm{min}_{l \in \{2,3,\dots,n\}}\{d^*(\{2,3,\dots,n\}, l)
    + d_{l1}\}. 
\end{equation}

Using the last two equations, the quantities $d^*(S,l)$ can be computed
recursively and the minimal tour length $d^**$ can be found.
In a second step, the optimal permutation can be computed 
in reverse order, staring with $i_n$ and working succesively back to
$i_2$. It exploits the fact that a permutation $\pi$ can only be optimal,
if

\begin{equation}
    d^{**} = d^*(\{2,3,\dots,n\}, i_n) + d_{i_n1}
\end{equation}
and, for $2 \le p \le n-1$,
\begin{equation}
    d^*(\{i_2, i_3,\dots, i_p, i_{p+1}\}, i_{p+1}) = 
    d^*(\{i_2,i_3,\dots,i_p\}, i_p) + d_{i_pi_{p+1}}.
\end{equation}

The space complexity needed to store the values for 
all $d^*(S,l)$ is $(n-1)2^{n-2}$ which severely restricts the
a dynamic programming algorithm to only TSP problems of small sizes.
However, for very small TSP instances the approach is very time efficient.

Branch-and-bound uses a differnt search strategy. The problem of minimizing the
tour length is recursively divided into subproblems (branching) which form a
search tree. For the subproblems fast ways to find lower and upper bounds of
the optimal solution in the subproblem are found (bounding). Using this bounds
subproblems can be discarded (pruned) if another subproblem is found with a
upper bound smaller than the former problem's lower bound.
If the upper and lower bound of a subproblem fall together, the subproblem
is solved. The procedure stops if all subproblems ar either pruned or solved
and thus the solution to the main problem is found.

% cite
%A. H. Land and A. G. Doig, An Automatic Method for Solving Discrete Programming% Problems Econometrica, Vol.28 (1960), pp. 497-520.





In \pkg{TSP}, we provide an interface to 
Concorde~\citep{Applegate2000}, a solver which
uses for extremely small instances dynamic programming and 
for larger instances a branch-and-bound variation.


\subsection{Heuristics for the TSP}\label{sec:heuristics}

The NP-completeness of the TSP makes it already for medium sized TSP instances
more time efficient to rely on heuristics. 
TSP heuristics typically fall into two groups, tour construction heuristics
and tour improvement heuristics.
In \pkg{TSP}, we implemented some simple tour construction
heuristics described by \cite{Rosenkrantz1977}: the nearest neighbor algorithm
and some variants of the insertion algorithm.
As tour imporvement heuristics we implemented a heuristic
which exchanges two edges in the graph representation of the 
TSP~\citep{Croes1958} and we provide an interface to the 
implementation of the Lin-Kernighan heuristic~\citep{Lin1973}
provided with Concorde~\citep{Applegate2003}.

A good overview of heuristics together with an experimental comparison 
can be found in~\cite{Johnson2002}.

In the following, we present the differnt available algorithms.


\section{The TSP package}
\subsection{Computational infrastructure}\label{sec:infrastructure}

In the package~\pkg{TSP}, a traveling salesperson problem is
defined by an object of class \class{TSP} (symmetric) or \class{ATSP}
(asymmetric). \func{solve\_TSP} 
is used to find a solution, which is represented by
an object of class \class{TOUR}. Figure~\ref{fig:overview} gives a overview
of this infrastructure.

\begin{figure}
    \centering
    \includegraphics[width=14cm]{overview}
    \caption{An overview of the classes in \pkg{TSP}.\label{fig:overview}}
\end{figure}


\class{TSP} objects can be created from a distance matrix (a \class{dist}
object) or a symmetric matrix using the creator function \func{TSP} or coercion
with \func{as.TSP}.  Similarly, \class{ATSP} objects are created by \func{ATSP}
or \func{as.ATSP} from square matrices representing the distances.  In the
creation process, labels are taken and stored as city names in the object or
can be explicitely given as arguments to the creator functions.  Several
methods are defined for the classes:
\begin{itemize}
    \item \func{print} displays basic information about the problem (number of
        cities and the used distance measure).
    \item \func{n\_of\_cities} returns the number of cities.
    \item \func{labels} returns the city names.
    \item \func{image} produces a shaded matrix plot of the distances
        between cities. The order of the cities can be specified as the
        argument \code{order}.
\end{itemize}

Internally, an object of class \class{TSP} is a \class{dist} object and, 
therefore, if needed, can be coerced to \class{dist} or to a matrix.
An \class{ATSP} object is represented as a square matrix.
Obviously, asymmetric TSPs are more general than symmetric TSPs, hence,
symmetric TSPs can also be represented as asymmetric TSPs.
To formulate an asymmetric TSP as a symmetric TSP with
double the number of cities, \func{ATSP\_to\_TSP}
is provides. The function creates the necessary dummy cities and
adapts the distance matrix accordingly. 

A popular format to save TSP descriptions to disk which is supported by
most TSP solvers is the format used by \emph{TSPLIB}, a library of
sample instances of the TSP maintained by \cite{Reinelt2004}. The
\pkg{TSP} package provides \func{read\_TSPLIB} and \func{write\_TSPLIB}
to read and save symmetric and asymmetric TSPs.

The class \class{TOUR} represents a solution to a TSP in form of an integer
permutation vector containing the ordered indices and labels of the cities to
visit. In addition, it stores an attribute indicating the length of the tour.
Again, suitable \func{print} and \func{labels} methods are provided.  The raw
permutation vector (i.e., the order in which cities are visited) can be
obtained from a tour using \func{as.integer}. With \func{cut\_tour}, a
circular tour can be split at a specified city resulting in a path represented
by a vector of city indices.

The length of a tour can always be calculated using \func{tour\_length} and
specifying a TSP and a tour. Instead of the tour, an integer permutation vector
calculated outside the \pkg{TSP} package can be used as long as it has the
correct length.

All TSP solvers in \pkg{TSP} use the simple common interface:

\begin{center}
\code{solve\_TSP(x, method, control)} 
\end{center}
where \code{x} is the TSP to be solved, \code{method} is a character
string indicating the method used to solve the TSP and \code{control}
can contain a list with additional information used by the solver.  The
different algorithms currently available as methods are described in
Section~\ref{sec:algo}.

\subsection{Algorithms and heuristics}\label{sec:algo}

Exact solutions for a TSP can be calculated using dynamic
programming~\citep{Held1962}, however, due to the exponential
space requirements, this approach is limited to very small instances.
A modern approach is to use branch-and-bound to find the optimal
solution. In \pkg{TSP}, we provide an interface to 
Concorde~\citep{Applegate2000}, a solver which
uses for extremely small instances dynamic programming and 
for larger instances a branch-and-bound variation.

The NP-completeness of the TSP makes it already for medium sized TSP instances
more time efficient to rely on heuristics. 
TSP heuristics typically fall into two groups, tour construction heuristics
and tour improvement heuristics.
In \pkg{TSP}, we implemented some simple tour construction
heuristics described by \cite{Rosenkrantz1977}: the nearest neighbor algorithm
and some variants of the insertion algorithm.
As tour imporvement heuristics we implemented a heuristic
which exchanges two edges in the graph representation of the 
TSP~\citep{Croes1958} and we provide an interface to the 
implementation of the Lin-Kernighan heuristic~\citep{Lin1973}
provided with Concorde~\citep{Applegate2003}.

A good overview of heuristics together with an experimental comparison 
can be found in~\cite{Johnson2002}.

In the following, we present the differnt available algorithms.

\subsection{Nearest neighbor algorithm}
The nearest neighbor algorithm~\citep{Rosenkrantz1977} 
is a tour construction algorithm which follows a very simple greedy procedure:
The algorithm starts with a tour containing a randomly chosen city.  Then the
algorithm always adds to the last city in the tour the nearest not yet visited
city. The algorithm stops when all cities are on the tour.  This algorithm is
implemented as method \code{"nn"} for \func{solve\_TSP}.

An extension to this algorithm is to repeat it with each city as
the starting point and then return the best of the found tours. 
This algorithm is implemented as method \code{"repetitive\_nn"}.

\subsection{Insertion algorithms}
All insertion algorithms~\citep{Rosenkrantz1977} start constructing a tour with
a tour consisting of an arbitrary city and then choose in each step a city $k$
not yet on the tour.  This city is inserted into the existing tour between two
consecutive cities $i$ and $j$, such that $$d(i,k) + d(k,j) - d(i,j)$$ is
minimized.  The algorithms stops when all cities are on the tour.

The insertion algorithms differ in the way the city to be inserted next is
chosen. The following insertion algorithms are implemented:

\begin{description}
\item[Nearest insertion] The city $k$ is chosen in each step as
the city which is \emph{nearest} to a city on the tour.

\item[Farthest insertion] The city $k$ is chosen in each step as
the city which is \emph{farthest} to any of the cities on the tour.

\item[Cheapest insertion] The city $k$ is chosen in each step 
such that the cost of inserting the new city (i.e., the increase
in the tour's length) is minimal.

\item[Arbitrary insertion] The city $k$ is chosen randomly from all cities
not yet on the tour.

\end{description}


The nearest and cheapest insertion algorithms are variants of to the minimum
spanning tree algorithm which is known to be a good algorithm to find a
Hamiltonian cycle with a close to minimal weight sum in a connected, undirected
graph.  For nearest and cheapest insertion, adding a city to a partial tour
corresponds to adding an edge to a partial spanning tree.  
For TSPs with distances obeying the triangular inequality, the upper bound for
the length of the tour found by the minimum spanning tree algorithm is twice
the optimal tour length.

The idea behind the farthest insertion algorithm is to link cities far outside
into the tour fist to establish an outline of the whole tour early. With this
change, the algorithm cannot be directly related to generating a minimum
spanning tree and thus the upper bound stated above cannot be guaranteed.
However, it can was shown that the algorithm generates tours which approach
$2/3$ times the optimal tour length~\citep{Johnson1985}. 

The insertion algorithms are implemented as methods 
\code{"nearest\_insertion"},
\code{"farthest\_insertion"},
\code{"cheapest\_insertion"} and
\code{"arbitrary\_insertion"}.



\subsection{Edge exchange algorithms}
2-opt
Lin-Kernighan
\marginpar{missing}

\subsection{Concorde}

Concorde~\citep{Applegate2000,Applegate2006} is currently one of the best
implementations for solving symmetric TSPs based on the branch-and-cut method.
\marginpar{more on the algorithm!}
In May 2004, Concorde was used to find the optimal solution for the TSP of
visiting all 24,978 cities in Sweden. The computation was carried out on a
cluster with 96 nodes and took in total almost 100 CPU years (assuming a single
CPU Xeon 2.8 GHz processor).

\pkg{TSP} provides a simple interface to Concorde which is used for method
\code{"concorde"}.  It saves the TSP using \func{write\_TSPLIB} and then calls
the Concorde executable and reads back the resulting tour.

\section{Examples}\label{sec:examples}

\subsection{Comparing some heuristics}

In the following example, we use several heuristics to find a short path
in the \code{USCA50} data set which contains the distances between the
first 50 cities in the \code{USCA312} data set. The \code{USCA312} data
set contains the distances between 312 cities in the USA and Canada
coded as a symmetric TSP.  The smaller data set is used here, since some
of the heuristic solvers employed are rather slow.

<<>>=
library("TSP")
data("USCA50")
tsp <- USCA50
tsp
@


We calculate tours using different heuristics and store the results in the the
list \code{tours}. As an example, we show the first tour which displays the
used method, the number of cities involved and the tour length.  All tour
lengths are compared using the dot chart in Figure~\ref{fig:dotchart}.  For the
chart, we add a point for the optimal solution which has a tour length of
14497. The optimal solution can be found using Concorde (\code{method =
"concorde"}).  It is omitted here, since Concorde has to be installed
separately.

<<echo=FALSE>>=
set.seed(1234)
@


<<fig=TRUE, include=FALSE, label=dotchart_USCA50, width=7, height=4>>=
methods <- c("nearest_insertion", "farthest_insertion", "cheapest_insertion",
    "arbitrary_insertion", "nn", "repetitive_nn", "2-opt")

tours <- lapply(methods, FUN = function(m) solve_TSP(tsp, method = m))
names(tours) <- methods
# tours$concorde  <- solve_TSP(tsp, method = "concorde")
# tours$concorde  <- solve_TSP(tsp, method = "linkern")

tours[[1]]


opt <- 14497
dotchart(c(sapply(tours, FUN = attr, "tour_length"), optimal = opt), 
xlab = "tour length", xlim = c(0, 20000))
## add optimum
#abline(v = opt, col = "red")
#mtext("optimum", at = opt, side = 3, col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-dotchart_USCA50}
\caption{Comparison of the tour lengths for the USCA50 data set.}
\label{fig:dotchart}
\end{figure}


\subsection{Finding the shortest Hamiltonian path}

The problem of finding the shortest Hamiltonian path through a graph can be
transformed into the TSP with cities and distances representing the graphs
vertices and edge weights, respectively~\citep{Garfinkel1985}. 

Finding the shortest Hamiltonian path through all cities disregarding
the endpoints can be achieved by inserting a `dummy city' which has a
distance of zero to all other cities. The position of this city in the
final tour represents the cutting point for the path. In the following
we use a heuristic to find a short path in the \code{USCA312} data set.
Inserting dummy cities is implemented in \pkg{TSP} as
\func{insert\_dummy}.

<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
library("TSP")
data("USCA312")
tsp <- insert_dummy(USCA312, label = "cut")
tsp
@

The TSP contains now an additional dummy city and we can try to solve this
TSP and print the labels to see the resulting tour.

<<>>=
tour <- solve_TSP(tsp, method="farthest_insertion")
#tour <- solve_TSP(tsp, method ="concorde")
tour
@

Since the dummy city has distance zero to all other cities, the path length is
equal to the tour length reported above. The path starts with the first city in
the list after the `dummy' city  and ends with the city right before it. 
We use \func{cut\_path} to create a path and show the 
first and last 6 cities on it.

<<>>=
path <- cut_tour(tour, "cut")
head(labels(path))
tail(labels(path))
@

The tour found in the example results in a path from Prince Rupert in
British Columbia to Lihue on Hawaii. Such a tour can also be 
visualized using the packages \pkg{sp}, \pkg{maps} and \pkg{maptools}.

<<fig=TRUE, include=FALSE, label=map1, width=8, height=8>>=
library("maps")
library("sp")
library("maptools")

data("USCA312_map")

plot_path <- function(path){
    plot(as(USCA312_coords, "Spatial"), axes = TRUE)
    plot(USCA312_basemap, add = TRUE, col = "gray")
    points(USCA312_coords, pch = 3, cex = 0.4, col = "red")
    
    path_line <- SpatialLines(list(Lines(list(Line(USCA312_coords[path,])))))
    plot(path_line, add=TRUE, col = "black")
    points(USCA312_coords[c(head(path,1), tail(path,1)),], pch = 19, 
        col = "black")
}

plot_path(path)
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map1}
\caption{A ``short'' Hamiltonian path for the USCA312 dataset.}
\label{fig:map1}
\end{figure}

The map containing the path is presented in Figure~\ref{fig:map1}.
It has to be mentioned, that the
path found by the used heuristic is almost double the optimal path length found
by Concorde with a length of $34928$, ilustrating the power of modern 
TSP algorithms.

For the following two examples, we show in a very low level way how the
distance matrix between cities can be modified to solve related shortest
Hamiltonian path problems. These examples serve as illustrations of how
modifications can be made to transform different problems into a TSP.

The first problem is to find the shortest Hamiltonian path starting with a
given city. In this case, all distances to the selected city are set to zero,
forcing the evaluation of all possible paths starting with this city and
disregarding the way back from the final city in the tour.  By modifying the
distances the symmetric TSP is changed into an asymmetric TSP since the
distances between the starting city and all other cities are no longer
symmetric.

As an example, we choose the city New York to be the starting city.
We transform the data set into an asymmetric TSP and set the column 
corresponding to New York to zero before solving the TSP. This means
that the distance to return from the last city in the path
to New York does not contribute to the path length.
We use the nearest insertion heuristic 
to calculate a tour and then cut at New York City to create a path.


<<echo=FALSE>>=
set.seed(1234)
@

<<fig=TRUE, include=FALSE, label=map2, width=8, height=8>>=
atsp <- as.ATSP(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
atsp[, ny] <- 0
tour <- solve_TSP(atsp, method ="nearest_insertion")
tour
path <- cut_tour(tour, ny, exclude_cut = FALSE)

plot_path(path)

head(labels(path))
tail(labels(path))
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map2}
\caption{A Hamiltonian path for the USCA312 dataset starting in New York City.}
\label{fig:map2}
\end{figure}

The found path 
is presented in Figure~\ref{fig:map2}. It
begins with New York City and cities in New Jersey and
ends in north east of Canada. 
%The path shows the typical behavior 
%of the nearest neighbor heuristic with first connecting the cities close by and
%then making rather big ``jumps'' for the final cities.

Finding the shortest Hamiltonian path which ends in a given city can be achieved
likewise by setting the row corresponding to this city in the distance
matrix to zero.

For finding the shortest Hamiltonian path we can also restrict both end points.
This problem can be transformed to a TSP by replacing the two cities by a
single city which contains the distances from the start point in the columns
and the distances to the end point in the rows. Obviously this is again an
asymmetric TSP.

For the following example, we are only interested in paths starting in New York
and ending in Los Angeles. Therefore, we remove the two cities from the
distance matrix, create an asymmetric TSP and insert a dummy city called
\code{"LA/NY"}. The distances from this dummy city are replaced by the
distances from New York and the distances towards are replaced by the distances
towards Los Angeles.


<<echo=FALSE>>=
set.seed(1234)
@

<<>>=
m <- as.matrix(USCA312)
ny <- which(labels(USCA312) == "New York, NY")
la <- which(labels(USCA312) == "Los Angeles, CA")

atsp <- ATSP(m[-c(ny,la), -c(ny,la)])
atsp <- insert_dummy(atsp, label = "LA/NY")

la_ny <- which(labels(atsp) == "LA/NY")
atsp[la_ny, ] <- c(m[-c(ny,la), ny], 0)
atsp[, la_ny] <- c(m[la, -c(ny,la)], 0)
@

We use again the nearest insertion heuristic.

<<fig=TRUE, include=FALSE, label=map3, width=8, height=8>>=
tour <- solve_TSP(atsp, method ="nearest_insertion")
tour

path_labels <- c("New York, NY", 
    labels(cut_tour(tour, la_ny)), "Los Angeles, CA")
path_ids <- match(path_labels, labels(USCA312))

head(path_labels)
tail(path_labels)

plot_path(path_ids)
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-map3}
\caption{A Hamiltonian path for the USCA312 dataset starting in New York City
and ending in Los Angles.}
\label{fig:map3}
\end{figure}

The path moves from New York on to other cities close in the State of New York
and it passes through cities in California before ending in Los Angeles.
The whole path is displayed in Figure~\ref{fig:map3}.


\subsection{Rearrangement clustering}
\cite{Climer2006} introduce rearrangement clustering by arranging all objects
in a linear order using a TSP. The authors suggest to find the cluster
boundaries of $k$ clusters by adding $k$ \emph{dummy cities} which have
constant distance $c$ to all other cities and are infinitely far from each
other. \cite{Climer2006} show that in the optimal solution of the TSP, the
dummy cities must separate the most distant cities and thus lie exactly on the
optimal cluster boundaries.

For the example, we use the well known iris data set. Since we know that the
dataset contains thre classes denoted by the attribute called \code{"Species"},
we insert three dummy cities into the TSP for the iris data set and perform
rearrangement clustering using the nearest insertion algorithm. Note that this
algorithm does not find the optimal solution and it is not guaranteed that the
dummy cities will present the optimal cluster boundaries.

<<echo=FALSE>>=
set.seed(4444)
@
<<>>=
data("iris")
tsp <- TSP(dist(iris[-5]), labels = iris[, "Species"])
#tsp <- TSP(dist(scale(iris[-5])))
tsp_dummy <- insert_dummy(tsp, n = 3, label = "boundary")
tour <- solve_TSP(tsp_dummy)
@

Next, we plot the TSP's permuted distance matrix using shading to
represent distances. The result is displayed as
Figure~\ref{fig:clustering}. Lighter areas represent larger
distances. The additional red lines represent the positions of the dummy
cities in the tour, which mark the found boundaries of the clusters.


<<fig=TRUE, include=FALSE, label=clustering>>=
## plot the distance matrix
image(tsp_dummy, tour)

## draw lines where the dummy cities are located
abline(h = which(labels(tour)=="boundary"), col = "red")
abline(v = which(labels(tour)=="boundary"), col = "red")
@

\begin{figure}
\centering
\includegraphics[width=10cm]{TSP-clustering}
\caption{Result of rearrangement clustering using three dummy cities and the 
nearest insertion algorithm on the iris data set.}
\label{fig:clustering}
\end{figure}


One pair of red horizontal and vertical lines exactly separates the darker from
lighter areas. The second pair occurs inside the larger dark.  We can look at
how well the found partitioning fits the structure in the data given by the
species field in the data set. Since we used the species as the city labels in
the TSP, the labels in the tour represent the partitioning with the dummy
cities named `boundary' seperating groups.

<<>>=
labels(tour)

## do Concorde
# tour <- solve_TSP(tsp_dummy, method = "concorde")
# labels(tour)
@


On boundary perfectly splits the iris data set into a group containing only
examples of the species `Setosa' and a second group containing examples for
`Virginica' and `Versicolor'. However, the second boundary only separates two
examples of the species `Virginica' from other examples of the same species.
This indicates that in the path generated by the TSP at exactly this point a
large jump must have ocurred.  Even in the optimal tour found by Concorde, this
problem occurs.  A reason why the rearrangement clustering fails to split the
data into three groups is the considerable overlap between the groups
`Virginica' and `Versicolor'.
\section{Conclusion}\label{sec:conclusion}

In this paper we presented the package \pkg{TSP} which implements the
infrastructure to handle and solve TSPs. The package introduces classes for
problem descriptions (\class{TSP} and \class{ATSP}) and for the solution
(\class{TOUR}). Together with a simple interface for solving TSPs, 
it allows for an easy and transparent usage of the package.

With the interface to Concorde, \pkg{TSP} also can use a state of the art
implementation which efficiently computes exact solutions using branch-and-cut.
%
\bibliographystyle{abbrvnat}
\bibliography{tsp}
%
\end{document}

